# マイクロサービス学習用プロジェクト

## 目的

* 概念や思想をちゃんと理解する
* 不向きな部分、デメリットも抑える
* Spring Framework、AWSの構築方法を習得する

## マイクロサービス

### 1. マイクロサービスとは

* **ビジネスドメインに基づいてモデル化** された、 **独立してデプロイ可能** なサービス
* サービス同士はネットワークを介して相互に通信
* サービス指向アーキテクチャ（SOA）の一種
* **新しい技術を使う必要はない。** どんな言語で、どんなプラットフォームでも良い

#### 1.1. 独立デプロイ可能性

* 他のサービスに影響を与えることなくデプロイできる
* サービス同士が疎結合

#### 1.2. ビジネスモデルに基づくモデル化

##### モノリシック（従来は）

* 3層アーキテクチャ（Web、App、DB）に対して、層ごと開発チームを形成していた
    * 機能ではなく技術のまとまりでチームを形成
    * DBは機能やチーム間で共有することが多いため、変更の影響が大きい

##### マイクロサービス

* 技術ではなく機能のまとまりでチームを形成する
* サービスのカプセル化が可能
    * サービス内に小さな3層アーキテクチャができる   
    * 他サービスへの影響を減らし、変更が容易になる
    * **DBの共有は、独立デプロイ可能性を実現するうえで一番の弊害**

#### 1.3. マイクロサービスの利点

* 各サービスの作業を並行して行える
* 1機能=1サービスなので、担当サービスの理解が容易
* サービスごと異なる言語、DB、開発手法の選択が可能

#### 1.4. マイクロサービスの課題

* サービス間のやりとりがネットワーク通信になるため、レイテンシーやネットワーク障害をより考慮する必要がある

#### 1.5. マイクロサービスのポイント

* 段階的にマイクロサービス化する。一気に大量のマイクロサービスを作らない
* 1サービスは小規模で
* 技術単位ではなく、機能単位の組織づくり
    * プロダクトオーナーや運用チームは、各々サービスチームごと配置
    * それらサービスを束ねる技術リーダーは別途設ける

### [2. モノリス（モノリシック）とは](doc/2.monolithic.md)

### [3. 結合と凝集](doc/3.coupling_cohesion.md)

### [4. 移行計画](doc/4.migration_plan.md)

### [5. モノリスの分割](doc/5.monolithic_division.md)

### 6. データベースの分割

* これまではシステムの話
* データも同じように分解してマイクロサービスに含める必要がある
* 1つのデータベースを複数のサービスが共有する構成が多い
    * あるデータに対して、どのサービスが利用して、どのサービスが所有者なのか判断が難しい
* 仮に分解ができなくとも、既存システムが利用するデータベースと切り分けるだけでも重要
    *  この観点で以下手法をまとめる

#### 6.1. データベースビュー

* 名前の通り、ビューを使う
* 物理的なデータ構造への依存度を減らすことができる

#### 6.2. データベースラッパー

* サービスが直接データベースにアクセスしないようにする
* データベースをラップするサービスを用意し、そのサービスを呼び出すように変更する
* データベースの分解が難しい時に適用できる
    * データベースのテーブル数を増やすことを防げる

#### 6.3. データベースの同期

* データベースの分割（=同期）方法
* 移行先データベース用意 → 移行元先でデータ同期をしながら一定期間利用
    * データベース間でデータベーストリガーやトランザクションログを利用して同期を取る
    * トラブルがあれば元に戻すため
* 問題がなくなったタイミングで、呼び出し元システムの切り替え含めて移行元データベースを削除
* 同期方法やタイミングによって、データの不整合が起きることを考慮

##### トレーサー書き込み

* （データベース間の同期処理ではなく）移行元システムから移行前のデータを更新しつつ、移行先のマイクロサービスも実行して同期を取る方法
    * データの移行が完全に終わったら、呼び出しを移行先のマイクロサービスに切り替える

#### 6.4. データベースとコードの分割順序

##### データベースから分割

* パフォーマンスやトランザクションの整合性に関する問題を早期に（サービスを分割する前に）発見できる
    * **このあたりが懸念としてある場合は、データベース分割から**
* データベース分割後にサービス（コード）を分割することに対して、
    * doma2、HibernateなどORM系ライブラリは、どのデータベースやテーブルを利用するかを明確に区別して
管理することができるのでコードの分割が容易になる

##### コードから分割

* だいたいこっちが多い
    * **データベース層の懸念が特になければ、コード分割から** 
* サービス層を分割することで、そのサービスで必要なデータが明確にしやすい
* データベースの分割に対して、サービスの分割はコストが少ない（短期的に着手できる）
* モノリス内でだけでAPIを分割するだけでも、データベースの隠蔽ができるのでこの後のマイクロサービスへの移行がしやすい

##### データベースとコード一緒に分割

* 段階的な検証や評価が難しいので非推奨。

#### 6.5. テーブルの分割

* カラム（データ）の所有者を明確にして、複数のサービスが１つのカラムを更新しないような作りにする
   * サービスAとサービスBがカラムCを直接更新ではなく
   * カラムCがサービスAの所有者だとすると
   * サービスBは、サービスAを介してカラムCを更新する

#### 6.6. 外部キー

* もともと外部キー参照しているテーブルを、別々のサービスに分解することは難しい（いろいろ考慮が必要
    * 一度のSQLで同時に取得できないので、レイテンシーが増える
    * データの一貫性も保証されない（削除できてしまう）ので事前チェックや削除処理制御が別途必要
* 考え方として、外部キー参照しているものは2つに分けないほうが良い可能性がある（ドメイン境界を見直す）
    
#### 6.7. 静的データ

* データ量かつ変更量が少ないデータは、そもそもデータベースで保持せず、サービスのEnumで定義する

#### 6.8. トランザクション

* データベースが分割される際、通常のデータベース側の原子性とは別に考慮が必要
   * 各サービスの別々のトランザクションを制御する必要がある
   * **2フェーズコミット**
       *  ただ行ロックが必要だし、あまり良い方法ではない気がする
* 原子性が必要なデータはそもそも分けないことが良い

#### 6.9. サーガ

* 2フェーズコミットなど分散トランザクションの代替案
* 1サービスの処理内で複数サブサービス（データベース）利用する際、サブサービスごとトランザクションを張る仕組み
   * 長時間の行ロックをしなくてすむ 
* （ただし）個々のトランザクションでエラーが発生したら、個々にロールバックもしくは再度更新処理を実行して対処する必要がある
   * 処理全体を一括でロールバックはできない
* サブサービスA→B→C→Dがあり、Cでエラーが発生した場合は、別途A、Bに対する復旧処理を用意する必要がある
* マイクロサービスではこれが一般的

### 6.10. 破壊的変更

#### 概要

* マイクロサービスの利用側に影響を与えないようにする必要がある
* 影響ないと思ってがっつり変えて本番環境にデプロイしたら、多機能に影響出たとか最悪
    *  もともとパラメータ2つだったけど、3つにした
    *  返すデータ構造を変えた
* マイクロサービスやチームの数が増えれば増えるほど、この問題は顕在化する

#### 対策

* テストを頻繁に行うことが最良の検出方法
* 変更を加えたら（検出したら）関係者に素早く周知すること
* そもそも破壊的変更で環なく、拡張する形に変更ができないか検討
* 変更前後のマイクロサービスを同時稼働させる
   * 変更後のデプロイ環境追加、変更前後の利用データ互換性など意識すべきことが増えて結構負担
* 1つのマイクロサービス内で互換性を持たせる
   * マイクロサービス内に変更前後のAPIを両方持つ

### 6.11. 監視

* ログや監視は、モノリスに比べて見るべきプロセスが増える
* どちらにせよ、1つのサービスに集約することが望ましい（ログ収集マイクロサービスなど）
   * 各マイクロサービスを利用する際にゲートウェイ的なものを通せば、収集が可能

### 6.12. 開発方法

#### 概要

* マイクロサービスいっぱいあると、開発対象のサービスを作るためにいくつかのマイクロサービスが必要
* 所有する開発PCで全部起動できなくなる

#### 対策

* スタブ化する
* 別サーバで立てたサービスを利用する
* **Telepresence** ってのがうまい具合にマイクロサービスを管理してくれるっぽい
* 本番環境では、 **Kubertetes** など使って管理するのが良い

5.8. aaaa TODO
5.9. aaaa
5.10. aaaa
5.11. aaaa
5.12. aaaa

### fff

## 構築

### Spring Framework

### AWS

## 参考

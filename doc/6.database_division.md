# 6. データベースの分割

* これまではシステムの話
* データも同じように分解してマイクロサービスに含める必要がある
* 1つのデータベースを複数のサービスが共有する構成が多い
    * あるデータに対して、どのサービスが利用して、どのサービスが所有者なのか判断が難しい
* 仮に分解ができなくとも、既存システムが利用するデータベースと切り分けるだけでも重要
    *  この観点で以下手法をまとめる

## 6.1. データベースビュー

* 名前の通り、ビューを使う
* 物理的なデータ構造への依存度を減らすことができる

## 6.2. データベースラッパー

* サービスが直接データベースにアクセスしないようにする
* データベースをラップするサービスを用意し、そのサービスを呼び出すように変更する
* データベースの分解が難しい時に適用できる
    * データベースのテーブル数を増やすことを防げる

## 6.3. データベースの同期

* データベースの分割（=同期）方法
* 移行先データベース用意 → 移行元先でデータ同期をしながら一定期間利用
    * データベース間でデータベーストリガーやトランザクションログを利用して同期を取る
    * トラブルがあれば元に戻すため
* 問題がなくなったタイミングで、呼び出し元システムの切り替え含めて移行元データベースを削除
* 同期方法やタイミングによって、データの不整合が起きることを考慮

### トレーサー書き込み

* （データベース間の同期処理ではなく）移行元システムから移行前のデータを更新しつつ、移行先のマイクロサービスも実行して同期を取る方法
    * データの移行が完全に終わったら、呼び出しを移行先のマイクロサービスに切り替える

## 6.4. データベースとコードの分割順序

### データベースから分割

* パフォーマンスやトランザクションの整合性に関する問題を早期に（サービスを分割する前に）発見できる
    * **このあたりが懸念としてある場合は、データベース分割から**
* データベース分割後にサービス（コード）を分割することに対して、
    * doma2、HibernateなどORM系ライブラリは、どのデータベースやテーブルを利用するかを明確に区別して
管理することができるのでコードの分割が容易になる

### コードから分割

* だいたいこっちが多い
    * **データベース層の懸念が特になければ、コード分割から** 
* サービス層を分割することで、そのサービスで必要なデータが明確にしやすい
* データベースの分割に対して、サービスの分割はコストが少ない（短期的に着手できる）
* モノリス内でだけでAPIを分割するだけでも、データベースの隠蔽ができるのでこの後のマイクロサービスへの移行がしやすい

### データベースとコード一緒に分割

* 段階的な検証や評価が難しいので非推奨。

## 6.5. テーブルの分割

* カラム（データ）の所有者を明確にして、複数のサービスが１つのカラムを更新しないような作りにする
   * サービスAとサービスBがカラムCを直接更新ではなく
   * カラムCがサービスAの所有者だとすると
   * サービスBは、サービスAを介してカラムCを更新する

## 6.6. 外部キー

* もともと外部キー参照しているテーブルを、別々のサービスに分解することは難しい（いろいろ考慮が必要
    * 一度のSQLで同時に取得できないので、レイテンシーが増える
    * データの一貫性も保証されない（削除できてしまう）ので事前チェックや削除処理制御が別途必要
* 考え方として、外部キー参照しているものは2つに分けないほうが良い可能性がある（ドメイン境界を見直す）
    
## 6.7. 静的データ

* データ量かつ変更量が少ないデータは、そもそもデータベースで保持せず、サービスのEnumで定義する

## 6.8. トランザクション

* データベースが分割される際、通常のデータベース側の原子性とは別に考慮が必要
   * 各サービスの別々のトランザクションを制御する必要がある
   * **2フェーズコミット**
       *  ただ行ロックが必要だし、あまり良い方法ではない気がする
* 原子性が必要なデータはそもそも分けないことが良い

## 6.9. サーガ

* 2フェーズコミットなど分散トランザクションの代替案
* 1サービスの処理内で複数サブサービス（データベース）利用する際、サブサービスごとトランザクションを張る仕組み
   * 長時間の行ロックをしなくてすむ 
* （ただし）個々のトランザクションでエラーが発生したら、個々にロールバックもしくは再度更新処理を実行して対処する必要がある
   * 処理全体を一括でロールバックはできない
* サブサービスA→B→C→Dがあり、Cでエラーが発生した場合は、別途A、Bに対する復旧処理を用意する必要がある
* マイクロサービスではこれが一般的

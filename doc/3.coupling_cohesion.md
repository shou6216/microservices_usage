# 3. 結合と凝集

* **結合** あるものに対する変更がどれくらい別のものの変更を必要とするか
* **凝集** 関連するコードをどのようにグループ化するか
* 「構造は、 **凝集度** が高く、 **結合度** が低い場合に安定する」
* マイクロサービスの変更量を減らす = 同じ機能を1つのサービスにまとめる = 凝集を高める

## 3.1. 実装結合

* 実装結合はよろしくない
   * データベースを共有した実装
       * 例）Aサービスのデータベースを、Bサービスが使う
       * Bサービスは、Aサービスのデータベース変更に追従できない（自分で直さないといけない）
       * こういう場合は、実装を隠すような形でAサービスにAPIを定義する
* APIは **アウトサイドイン思考** で考えると良い
   * アウトサイドイン =  サービス利用者の視点からデザインする手法
   * インサイドアウト = 内部データや実装からデザインする手法。これはダメ

## 3.2. 一時的結合

* AサービスがBサービスのAPI実行 → BサービスがCサービスのAPIを実行  
のように、複数のAPIを同期的に呼び出している状態は **時間的な意味で** 結合した状態といえる。
    * キャッシュを使ったり、非同期通信にすることで結合度を下げる

## 3.3. デプロイ度結合

* 複数モジュールからなる単一プロセスにおいて、任意のモジュールを変更した場合
その変更をデプロイするためには、変更していないモジュールも含めて全体をデプロイしないといけない
（モノリスではほぼ当たり前の話）
     * 変更の必要があるものだけデプロイする仕組みや構成が望ましい（=マイクロサービス）
     * またリリースの規模（変更量の規模）が小さいほどリスクを減らせる（=マイクロサービス）
     * 継続的デリバリーが良い（=マイクロサービス）

## 3.4. ドメイン結合

* サービス間のデータ受け渡しにおいて、ドメイン（用途）を明確にして過不足のないようにすることが望ましい
    * **過** サービスで利用しない情報は送らない、受け取らない
    * **不足** 受け渡し後に、サービス内で別途データ取得処理をしないように、最初の受け渡しで必要分を用意する
* サービスをモデル化する上で、ドメイン駆動設計は重要
